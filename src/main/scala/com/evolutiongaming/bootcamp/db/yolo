// https://www.scala-exercises.org/doobie/


import doobie._
import doobie.implicits._
import doobie.util.ExecutionContexts
import doobie.implicits.javatime._
import cats._
import cats.data._
import cats.effect._
import cats.implicits._
import com.evolutiongaming.bootcamp.db.DbConfig._
import com.evolutiongaming.bootcamp.db.DbCommon._

// We need a ContextShift[IO] before we can construct a Transactor[IO]. The passed ExecutionContext
// is where nonblocking operations will be executed. For testing here we're using a synchronous EC.
implicit val cs = IO.contextShift(ExecutionContexts.synchronous)

// A transactor that gets connections from java.sql.DriverManager and executes blocking operations
// on an our synchronous EC. See the chapter on connection handling for more info.
val xa = Transactor.fromDriverManager[IO](
  driver = dbDriverName,
  url = dbUrl,
  user = dbUser,
  pass = dbPwd,
  Blocker.liftExecutionContext(ExecutionContexts.synchronous) // just for testing
)

val y = xa.yolo
import y._

val setup = for {
  _ <- Fragment.const(authorsSql).update.run.transact(xa)
  _ <- Fragment.const(booksSql).update.run.transact(xa)
  _ <- Fragment.const(populateDataSql).update.run.transact(xa)
} yield ()

setup.unsafeRunSync()

/*

sql"select name from authors"
   .query[String]
   .stream
   .take(1)
   .quick
   .unsafeRunSync()

===

val names = sql"select name from authors".query[String].stream.transact(xa)
names.take(5).compile.toVector.unsafeRunSync().foreach(println(_))

===

import com.evolutiongaming.bootcamp.db.Author

sql"select id, name, birthday from authors".query[Author].stream.take(1).quick.unsafeRunSync()

===


sql"select id, name, birthday from authors".query[Author].check.unsafeRunSync

*/